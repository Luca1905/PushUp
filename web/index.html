<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Push-up Game (Web)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body { margin: 0; background: #111; color: #eee; font-family: system-ui, Arial, sans-serif; }
      header { padding: 12px; background: #222; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; position: sticky; top: 0; z-index: 10; border-bottom: 1px solid #333; }
      header label { display: flex; align-items: center; gap: 6px; }
      header input { padding: 10px 12px; background: #111; color: #eee; border: 1px solid #444; border-radius: 10px; }
      header button { padding: 10px 14px; background: #0a84ff; color: #fff; border: 0; border-radius: 10px; cursor: pointer; font-weight: 600; }
      header button:hover { filter: brightness(1.1); }
      main { position: relative; display: flex; justify-content: center; padding: 16px; }
      #wrap { position: relative; width: min(96vw, 1100px); margin-inline: auto; }
      /* Make video the base layer; canvas overlays it */
      #wrap video { display: block; width: 100%; height: auto; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,.45); background: #000; }
      #wrap canvas { position: absolute; inset: 0; width: 100%; height: 100%; border-radius: 12px; pointer-events: none; }
      #status { margin-left: auto; opacity: .9; padding: 6px 10px; border-radius: 999px; background: #1b1b1b; border: 1px solid #333; }
      @media (max-width: 640px) {
        header { gap: 8px; }
        header label { flex: 1; min-width: 120px; }
        header input { width: 100%; box-sizing: border-box; }
        #wrap { width: 100vw; }
      }
    </style>
    <script type="module">
      import { FilesetResolver, PoseLandmarker, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

      const els = {
        room: null, name: null, connectBtn: null, status: null,
        video: null, canvas: null,
      };

      let ws = null;
      let leader = [];
      let count = 0, sentCount = -1, lastSentTs = 0;
      let stage = "UP"; // "UP" | "DOWN"
      let lastTs = 0;
      let pose = null;
      let running = false;

      function angleDeg(ax, ay, bx, by, cx, cy) {
        const baxx = ax - bx, baxy = ay - by;
        const bcx = cx - bx, bcy = cy - by;
        const nba = Math.hypot(baxx, baxy) || 1;
        const nbc = Math.hypot(bcx, bcy) || 1;
        const dot = (baxx / nba) * (bcx / nbc) + (baxy / nba) * (bcy / nbc);
        const clamped = Math.max(-1, Math.min(1, dot));
        return Math.acos(clamped) * 180 / Math.PI;
      }

      function drawHUD(ctx, w, h) {
        // Local count (top-left)
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(12, 12, 220, 88);
        ctx.fillStyle = "#fff";
        ctx.font = "20px system-ui, Arial";
        ctx.fillText(`Reps: ${count}`, 26, 50);

        // Leaderboard (top-right)
        const pad = 12, lbw = 270;
        const rows = Math.min(10, leader.length);
        const boxH = 30 + 24 * rows;
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(w - lbw - pad, pad, lbw, boxH);
        ctx.fillStyle = "#fff";
        ctx.font = "16px system-ui, Arial";
        ctx.fillText("Leaderboard", w - lbw - pad + 12, pad + 20);
        ctx.fillStyle = "rgb(220,220,220)";
        ctx.font = "14px system-ui, Arial";
        for (let i = 0; i < rows; i++) {
          const p = leader[i];
          const nm = (p.name || "").slice(0, 14).padEnd(14, " ");
          const line = `${i + 1}. ${nm}  ${p.count}`;
          ctx.fillText(line, w - lbw - pad + 12, pad + 20 + 24 * (i + 1));
        }
        ctx.restore();
      }

      function sendUpdateMaybe() {
        const now = performance.now() / 1000;
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        if (count !== sentCount || (now - lastSentTs) > 2.0) {
          ws.send(JSON.stringify({ type: "update", count: count|0 }));
          sentCount = count;
          lastSentTs = now;
        }
      }

      async function setupPose() {
        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        pose = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task",
          },
          runningMode: "VIDEO",
          numPoses: 1,
        });
      }

      async function setupCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false });
        els.video.srcObject = stream;
        await els.video.play();
      }

      function connectWS(uri) {
        if (ws) try { ws.close(); } catch {}
        ws = new WebSocket(uri);
        els.status.textContent = "Connecting...";
        ws.onopen = () => { els.status.textContent = "Connected"; sentCount = -1; lastSentTs = 0; };
        ws.onclose = () => { els.status.textContent = "Disconnected"; };
        ws.onerror = () => { els.status.textContent = "Error"; };
        ws.onmessage = (ev) => {
          try {
            const data = JSON.parse(ev.data);
            if (data.type === "leaderboard" || data.type === "join" || data.type === "leave") {
              leader = Array.isArray(data.players) ? data.players : [];
            }
          } catch {}
        };
        // keepalive pings
        setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            try { ws.send(JSON.stringify({ type: "ping" })); } catch {}
          }
        }, 10000);
      }

      async function loop() {
        if (!running) return;
        const ctx = els.canvas.getContext("2d");
        const vw = els.video.videoWidth;
        const vh = els.video.videoHeight;
        if (vw === 0 || vh === 0) return requestAnimationFrame(loop);

        // size canvas once
        if (els.canvas.width !== vw || els.canvas.height !== vh) {
          els.canvas.width = vw; els.canvas.height = vh;
        }

        // clear overlay (video is visible underneath)
        ctx.clearRect(0, 0, vw, vh);

        // Run pose
        if (pose) {
          const now = performance.now();
          const res = await pose.detectForVideo(els.video, now);

          // draw landmarks and count (do not draw the video on the canvas)
          if (res.landmarks && res.landmarks.length > 0) {
            const lms = res.landmarks[0]; // 33 BlazePose points
            const s = lms[12], e = lms[14], w = lms[16];
            if (s && e && w) {
              // normalized->pixel
              const sx = s.x * vw, sy = s.y * vh;
              const ex = e.x * vw, ey = e.y * vh;
              const wx = w.x * vw, wy = w.y * vh;
              const ang = angleDeg(sx, sy, ex, ey, wx, wy);

              // stage transitions
              if (ang < 70 && stage === "UP") stage = "DOWN";
              else if (ang > 160 && stage === "DOWN") { stage = "UP"; count++; sendUpdateMaybe(); }

              // viz elbow angle
              ctx.fillStyle = "rgba(0,0,0,0.6)";
              ctx.fillRect(10, vh - 34, 110, 26);
              ctx.fillStyle = "#0f0";
              ctx.font = "16px system-ui, Arial";
              ctx.fillText(`Elbow: ${ang|0}`, 16, vh - 16);

              // simple joints
              ctx.fillStyle = "#0af";
              for (const p of [s, e, w]) {
                ctx.beginPath(); ctx.arc(p.x * vw, p.y * vh, 5, 0, Math.PI * 2); ctx.fill();
              }
            }
          }

          // FPS (rough)
          const t = performance.now();
          const fps = lastTs ? 1000 / (t - lastTs) : 0;
          lastTs = t;
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(10, vh - 64, 90, 24);
          ctx.fillStyle = "#fff";
          ctx.font = "14px system-ui, Arial";
          ctx.fillText(`${fps.toFixed(1)} FPS`, 16, vh - 48);

          // HUD with count + leaderboard
          drawHUD(ctx, vw, vh);
        }

        requestAnimationFrame(loop);
      }

      async function start() {
        els.room = document.getElementById("room");
        els.name = document.getElementById("name");
        els.connectBtn = document.getElementById("connect");
        els.status = document.getElementById("status");
        els.video = document.getElementById("video");
        els.canvas = document.getElementById("canvas");

        // Prefill from URL params
        const url = new URL(location.href);
        els.room.value = (url.searchParams.get("room") || "ABCD").toUpperCase();
        els.name.value = url.searchParams.get("name") || "Player";

        await setupCamera();
        await setupPose();

        els.connectBtn.onclick = () => {
          const room = els.room.value.trim().toUpperCase();
          const name = encodeURIComponent(els.name.value.trim() || "Player");
          const wsScheme = location.protocol === "https:" ? "wss" : "ws";
          const wsBase = `${wsScheme}://${location.host}`;
          const uri = `${wsBase}/ws/${room}?name=${name}`;
          connectWS(uri);
          running = true;
          requestAnimationFrame(loop);
        };
      }

      start();
    </script>
  </head>
  <body>
    <header>
      <label>Room <input id="room" placeholder="ABCD" size="6" /></label>
      <label>Name <input id="name" placeholder="Your name" size="12" /></label>
      <button id="connect">Connect</button>
      <div id="status">Idle</div>
    </header>
    <main>
      <div id="wrap">
        <video id="video" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
      </div>
    </main>
  </body>
</html>